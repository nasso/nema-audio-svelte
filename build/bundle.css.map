{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "Icon.svelte",
    "Pane.svelte",
    "TextSpring.svelte",
    "Button.svelte",
    "Checkbox.svelte",
    "Knob.svelte",
    "TabbedControl.svelte",
    "FlexSpace.svelte",
    "SplitBar.svelte",
    "SplitPane.svelte",
    "Stack.svelte",
    "Tab.svelte",
    "TempoInput.svelte",
    "Toolbar.svelte",
    "NewTrackHead.svelte",
    "TrackHead.svelte",
    "Tracklist.svelte",
    "Graph.svelte",
    "InputPort.svelte",
    "Link.svelte",
    "Node.svelte",
    "OutputPort.svelte",
    "AudioWaveform.svelte",
    "Clip.svelte",
    "Timeline.svelte",
    "Track.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import { ui } from \"@app/stores/settings\";\nimport Pane from \"@components/Pane.svelte\";\nimport SplitPane from \"@components/layout/SplitPane.svelte\";\nimport Toolbar from \"@components/toolbar/Toolbar.svelte\";\nimport Tracklist from \"@components/tracklist/Tracklist.svelte\";\nimport player from \"./stores/player\";\nimport project from \"./stores/project\";\nconst paneSnaps = [200];\nlet releasedSpacebar = true;\n</script>\n\n<svelte:window\n  on:keydown={(e) => {\n    if (e.key === \" \" && releasedSpacebar) {\n      releasedSpacebar = false;\n\n      $player = $player.toggle($project);\n    }\n  }}\n  on:keyup={(e) => {\n    if (e.key === \" \") {\n      releasedSpacebar = true;\n    }\n  }}\n/>\n\n<main>\n  <Toolbar />\n  <SplitPane bind:splitpos={$ui.bottomPaneHeight} reverse snaps={paneSnaps}>\n    <SplitPane\n      bind:splitpos={$ui.sidePaneWidth}\n      direction=\"row\"\n      snaps={paneSnaps}\n    >\n      <Pane />\n      <Tracklist />\n    </SplitPane>\n    <Pane />\n  </SplitPane>\n</main>\n\n<style lang=\"scss\">main {\n  position: relative;\n  margin: 0;\n  padding: 4px;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  width: 100vw;\n  height: 100vh;\n  background: var(--color-background-0);\n  color: var(--color-foreground-0);\n  justify-content: stretch;\n}\nmain > :global(*) {\n  flex-grow: 1;\n}</style>\n",
    "<script lang=\"ts\" context=\"module\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst paths = {};\nconst parser = new DOMParser();\nfunction fetchPath(name) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const response = yield fetch(`icons/${name}.svg`);\n        const svgSource = yield response.text();\n        const svg = parser.parseFromString(svgSource, \"image/svg+xml\");\n        const pathElement = svg.getElementsByTagName(\"path\")[0];\n        return pathElement.getAttribute(\"d\");\n    });\n}\nfunction getIconPath(name) {\n    if (!paths[name]) {\n        paths[name] = fetchPath(name);\n    }\n    return paths[name];\n}\n</script>\n\n<script lang=\"ts\">export let name;\nexport let preload = [];\nexport let color = \"currentColor\";\nexport let size = \"1em\";\npreload.forEach(getIconPath);\n$: path = getIconPath(name);\n</script>\n\n<svg width={size} height={size} viewBox=\"0 0 24 24\">\n  {#await path then path}\n    <path d={path} fill={color} />\n  {/await}\n</svg>\n\n<style lang=\"scss\">path {\n  transition: fill var(--anim-short);\n}</style>\n",
    "<div />\n\n<style lang=\"scss\">div {\n  flex-grow: 1;\n  background: var(--color-background-1);\n  border-radius: var(--corner-radius);\n}</style>\n",
    "<script lang=\"ts\">export let shrinklimit = 0.8;\nlet available = 1;\nlet original_width = 1;\nconst clamp = (x, min, max) => {\n    return Math.min(Math.max(x, min), max);\n};\n$: scale_x = clamp(available / original_width, shrinklimit, 1);\n</script>\n\n<div class=\"root\" bind:clientWidth={available}>\n  <div class=\"original\" bind:clientWidth={original_width}>\n    <slot />\n  </div>\n  <div\n    class=\"shrinked\"\n    class:scrolling={original_width * shrinklimit > available}\n    style={`\n      --scale-x: ${scale_x};\n      --scroll-time: ${(original_width - available) / 20}s;\n    `}\n  >\n    <slot />\n  </div>\n</div>\n\n<style lang=\"scss\">.root {\n  display: block;\n  position: relative;\n  height: 1.2em;\n  overflow: hidden;\n}\n\n.original {\n  opacity: 0;\n  overflow: hidden;\n  white-space: nowrap;\n  position: absolute;\n}\n\n.shrinked {\n  white-space: nowrap;\n  position: absolute;\n  left: 0;\n  transform-origin: left;\n  transform: scaleX(var(--scale-x));\n}\n.shrinked.scrolling {\n  animation: scrolltext var(--scroll-time) linear;\n  animation-iteration-count: infinite;\n  animation-direction: repeat;\n}\n@keyframes scrolltext {\n  from, 20%, to {\n    left: 0%;\n    transform: scaleX(var(--scale-x)) translateX(0%);\n  }\n  75%, 90% {\n    left: 100%;\n    transform: scaleX(var(--scale-x)) translateX(-100%);\n  }\n}</style>\n",
    "<script lang=\"ts\">export let pressed = undefined;\n</script>\n\n<button on:click aria-pressed={pressed && `${pressed}`}>\n  <slot />\n</button>\n\n<style lang=\"scss\">button {\n  background: none;\n  color: inherit;\n  border: none;\n  padding: 0;\n  font: inherit;\n  cursor: pointer;\n  outline: inherit;\n  box-shadow: none;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: var(--corner-radius);\n  background-color: var(--color-background-1);\n  padding: 0px 8px;\n  transition: background-color var(--anim-short);\n}\nbutton:hover, button:focus {\n  background-color: var(--color-background-2);\n}\nbutton:active {\n  background-color: var(--color-background-1);\n}</style>\n",
    "<script lang=\"ts\">export let checked = false;\nexport let size = 12;\nexport let color = \"var(--color-accent)\";\n</script>\n\n<label class=\"checkbox\" on:contextmenu on:pointerdown|stopPropagation>\n  <input type=\"checkbox\" hidden bind:checked />\n  <svg width={size} height={size}>\n    <circle\n      cx=\"50%\"\n      cy=\"50%\"\n      r={size / 2 - 0.5}\n      stroke={color}\n      stroke-width=\"1px\"\n      fill=\"none\"\n    />\n\n    <g transform={`translate(${size / 2} ${size / 2})`}>\n      <circle\n        cx=\"0%\"\n        cy=\"0%\"\n        fill={color}\n        r={checked ? size / 4 : 0}\n        opacity={checked ? 1 : 0}\n        style=\"transition: r var(--anim-short), opacity var(--anim-short);\"\n      />\n    </g>\n  </svg>\n</label>\n\n<style lang=\"scss\">.checkbox {\n  line-height: 0;\n}\n.checkbox svg {\n  overflow: visible;\n}</style>\n",
    "<script lang=\"ts\">import { ui } from \"@app/stores/settings\";\nexport let id = undefined;\nexport let color = \"var(--color-accent)\";\nexport let disabledColor = \"var(--color-foreground-1)\";\nexport let size = 20;\nexport let type = \"absolute\";\nexport let value = 0;\nexport let disabled = false;\nexport let min = { absolute: 0, relative: -1 }[type];\nexport let max = { absolute: 1, relative: 1 }[type];\nexport let step = undefined;\nexport let clamp = true;\n$: normalized = (value - min) / (max - min);\n$: valueArcStart = (type === \"absolute\" ? 90 : 225) * (Math.PI / 180);\n$: valueArcEnd = (90 + normalized * 270) * (Math.PI / 180);\n$: valueArcLarge = valueArcEnd - valueArcStart > Math.PI;\n$: valueArcSide = valueArcEnd > valueArcStart;\n$: neutral = value === 0;\n$: if (clamp) {\n    value = Math.min(max, Math.max(min, value));\n}\nfunction handlePointerDown(e) {\n    if (e.button !== 0) {\n        return;\n    }\n    const usedPointerLock = $ui.usePointerLock;\n    this.onpointermove = (e) => {\n        value -= (e.movementY / 50) * (max - min) * 0.5;\n    };\n    this.onpointerup = (e) => {\n        this.onpointermove = null;\n        this.onpointerup = null;\n        if (usedPointerLock) {\n            document.exitPointerLock();\n        }\n        else {\n            this.releasePointerCapture(e.pointerId);\n        }\n    };\n    if (usedPointerLock) {\n        this.requestPointerLock();\n    }\n    else {\n        this.setPointerCapture(e.pointerId);\n    }\n}\n</script>\n\n<label\n  class=\"knob\"\n  style={`\n    color: ${disabled ? disabledColor : color};\n  `}\n>\n  <input\n    type=\"number\"\n    hidden\n    bind:value\n    {id}\n    {step}\n    {disabled}\n    min={clamp && min}\n    max={clamp && max}\n  />\n  <svg\n    width={size}\n    height={size}\n    on:pointerdown|stopPropagation={handlePointerDown}\n  >\n    <!-- Background -->\n    <circle opacity=\"0.1\" cx=\"50%\" cy=\"50%\" r={size / 2} fill=\"currentColor\" />\n\n    <!-- Stroked stuff -->\n    <g\n      stroke=\"currentColor\"\n      stroke-width=\"2\"\n      stroke-linecap=\"round\"\n      fill=\"none\"\n    >\n      <!-- Little line that shows the value -->\n      <g\n        transform={`translate(${size / 2} ${size / 2}) rotate(${\n          normalized * 270 - 135\n        })`}\n      >\n        <line\n          opacity={neutral ? 0.25 : 1}\n          style=\"transition: opacity var(--anim-short)\"\n          x1=\"0\"\n          y1={4 - size / 2}\n          x2=\"0\"\n          y2={6 - size / 2}\n        />\n      </g>\n\n      <!-- Track -->\n      <path\n        opacity=\"0.25\"\n        transform={`translate(${size / 2} ${size / 2}) rotate(-135)`}\n        d={`\n          M 0,${1 - size / 2}\n          A ${size / 2 - 1} ${size / 2 - 1} 0 1 1 ${1 - size / 2},0\n        `}\n      />\n\n      <!-- Value track -->\n      <path\n        transform={`translate(${size / 2} ${size / 2}) rotate(-135)`}\n        opacity={Math.abs(valueArcStart - valueArcEnd) < 0.001 ? 0.0 : 1.0}\n        style=\"transition: opacity var(--anim-short)\"\n        d={`\n          M ${Math.cos(valueArcStart) * (1 - size / 2)}\n            ${Math.sin(valueArcStart) * (1 - size / 2)}\n          A ${size / 2 - 1} ${size / 2 - 1} 0\n            ${valueArcLarge ? 1 : 0} ${valueArcSide ? 1 : 0}\n            ${Math.cos(valueArcEnd) * (1 - size / 2)}\n            ${Math.sin(valueArcEnd) * (1 - size / 2)}\n        `}\n      />\n    </g>\n  </svg>\n</label>\n\n<style lang=\"scss\">.knob {\n  line-height: 0;\n}</style>\n",
    "<script lang=\"ts\">import Tab from \"@components/layout/Tab.svelte\";\nexport let tabs;\nexport let selected;\n</script>\n\n<div class=\"tabbed-control\" role=\"tablist\">\n  {#each tabs as tab}\n    <Tab\n      icon={tab.icon}\n      selected={selected === tab.name}\n      on:click={() => (selected = tab.name)}\n    />\n  {/each}\n</div>\n\n<style lang=\"scss\">.tabbed-control {\n  display: flex;\n  flex-direction: row;\n  background-color: var(--color-background-1);\n  border-radius: var(--corner-radius);\n}</style>\n",
    "<div class=\"flex-space\" />\n\n<style lang=\"scss\">.flex-space {\n  flex-grow: 1;\n}</style>\n",
    "<script lang=\"ts\">export let position;\nexport let factor = 1;\nexport let direction = \"column\";\nexport let reverse = false;\nexport let snaps = undefined;\nexport let snapdist = 10;\nexport let min = undefined;\nexport let max = undefined;\nexport let color = \"var(--color-foreground-2)\";\n$: if (min) {\n    position = Math.max(min, position);\n}\n$: if (max) {\n    position = Math.min(max, position);\n}\n$: if (snaps) {\n    const candidates = snaps.filter((snap) => Math.abs(position - snap) < snapdist);\n    if (candidates.length) {\n        const closest = candidates.reduce((closestYet, snap) => {\n            if (Math.abs(snap - position) < Math.abs(closestYet - position)) {\n                return snap;\n            }\n            return closestYet;\n        });\n        position = closest;\n    }\n}\nfunction handlePointerDown(e) {\n    if (e.button !== 0) {\n        return;\n    }\n    const revFactor = reverse ? -1 : 1;\n    const startPos = position;\n    const pointerStart = { x: e.clientX, y: e.clientY };\n    this.onpointermove = (e) => {\n        let delta;\n        if (direction === \"column\") {\n            delta = (e.clientY - pointerStart.y) * factor * revFactor;\n        }\n        else if (direction === \"row\") {\n            delta = (e.clientX - pointerStart.x) * factor * revFactor;\n        }\n        position = startPos + delta;\n    };\n    this.onpointerup = (e) => {\n        this.onpointermove = null;\n        this.onpointerup = null;\n        this.releasePointerCapture(e.pointerId);\n    };\n    this.setPointerCapture(e.pointerId);\n}\n</script>\n\n<div class=\"split-bar\">\n  <div\n    class=\"hotspot\"\n    class:horizontal={direction === \"row\"}\n    class:vertical={direction === \"column\"}\n    style={`color: ${color}`}\n    on:pointerdown|stopPropagation={handlePointerDown}\n  />\n</div>\n\n<style lang=\"scss\">.split-bar {\n  display: inline-block;\n  position: relative;\n  --hotspot-size: 8px;\n}\n.split-bar .hotspot {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.split-bar .hotspot::before {\n  content: \"\";\n  --distance-to-edge: 8px;\n  --line-width: 2px;\n  position: absolute;\n  opacity: 0;\n  border-radius: calc(var(--line-width) / 2);\n  transition: opacity var(--anim-short);\n  background: currentColor;\n}\n.split-bar .hotspot:hover::before {\n  opacity: 0.5;\n}\n.split-bar .hotspot.horizontal {\n  cursor: ew-resize;\n  width: var(--hotspot-size);\n  transform: translateX(-50%);\n}\n.split-bar .hotspot.horizontal::before {\n  left: calc(50% - var(--line-width) / 2);\n  width: var(--line-width);\n  top: var(--distance-to-edge);\n  bottom: var(--distance-to-edge);\n}\n.split-bar .hotspot.vertical {\n  cursor: ns-resize;\n  height: var(--hotspot-size);\n  transform: translateY(-50%);\n}\n.split-bar .hotspot.vertical::before {\n  top: calc(50% - var(--line-width) / 2);\n  height: var(--line-width);\n  left: var(--distance-to-edge);\n  right: var(--distance-to-edge);\n}</style>\n",
    "<script lang=\"ts\">import SplitBar from \"./SplitBar.svelte\";\nexport let direction = \"column\";\nexport let splitpos;\nexport let reverse = false;\nexport let min = 100;\nexport let max = undefined;\nexport let snaps = undefined;\nexport let snapdist = undefined;\n</script>\n\n<div\n  class:vertical={direction === \"column\"}\n  class:horizontal={direction === \"row\"}\n  class:reverse\n  class=\"split-pane\"\n  style={`--split-pos: ${splitpos}px`}\n>\n  <slot />\n  <div class=\"splitter\">\n    <SplitBar\n      bind:position={splitpos}\n      {direction}\n      {reverse}\n      {min}\n      {max}\n      {snaps}\n      {snapdist}\n    />\n  </div>\n</div>\n\n<style lang=\"scss\">.split-pane {\n  display: inline-grid;\n  gap: 2px;\n  min-height: 0;\n  min-width: 0;\n}\n.split-pane.horizontal {\n  grid-template-columns: calc(var(--split-pos, 50%) - 2px) 0px calc(100% - var(--split-pos, 50%) - 2px);\n  grid-template-areas: \"first splitter second\";\n}\n.split-pane.horizontal.reverse {\n  grid-template-columns: calc(100% - var(--split-pos, 50%) - 2px) 0px calc(var(--split-pos, 50%) - 2px);\n}\n.split-pane.vertical {\n  grid-template-rows: calc(var(--split-pos, 50%) - 2px) 0px calc(100% - var(--split-pos, 50%) - 2px);\n  grid-template-areas: \"first\" \"splitter\" \"second\";\n}\n.split-pane.vertical.reverse {\n  grid-template-rows: calc(100% - var(--split-pos, 50%) - 2px) 0px calc(var(--split-pos, 50%) - 2px);\n}\n.split-pane .splitter {\n  grid-area: splitter;\n  display: grid;\n}\n.split-pane > :global(*):nth-child(1) {\n  grid-area: first;\n}\n.split-pane > :global(*):nth-child(2) {\n  grid-area: second;\n}</style>\n",
    "<script lang=\"ts\" context=\"module\">export function grow(node, amount = 1) {\n    node.style.flexGrow = `${amount}`;\n}\nexport function basis(node, basis) {\n    node.style.flexBasis = basis;\n}\n</script>\n\n<script lang=\"ts\">export let dir = \"horizontal\";\nexport let align = \"stretch\";\nexport let spacing = 0;\nexport let hpad = 0;\nexport let vpad = 0;\nexport let inline = false;\nexport let reverse = false;\n</script>\n\n<div\n  class=\"stack\"\n  class:inline\n  class:reverse\n  class:horizontal={dir === \"horizontal\"}\n  class:vertical={dir === \"vertical\"}\n  style={`\n    padding: ${vpad}px ${hpad}px;\n    gap: ${spacing}px;\n    align-items: ${\n      {\n        start: \"flex-start\",\n        center: \"center\",\n        end: \"flex-end\",\n        stretch: \"stretch\",\n      }[align]\n    };\n  `}\n>\n  <slot />\n</div>\n\n<style lang=\"scss\">.stack {\n  display: flex;\n}\n.stack.inline {\n  display: inline-flex;\n}\n.stack.horizontal {\n  flex-direction: row;\n}\n.stack.horizontal.reverse {\n  flex-direction: row-reverse;\n}\n.stack.vertical {\n  flex-direction: column;\n}\n.stack.vertical.reverse {\n  flex-direction: column-reverse;\n}</style>\n",
    "<script lang=\"ts\">import Icon from \"@components/Icon.svelte\";\nexport let icon;\nexport let selected = false;\n</script>\n\n<button class:selected role=\"tab\" tabindex={selected ? 0 : -1} on:click>\n  <Icon name={icon} />\n</button>\n\n<style lang=\"scss\">button {\n  background: none;\n  color: inherit;\n  border: none;\n  padding: 0;\n  font: inherit;\n  cursor: pointer;\n  outline: inherit;\n  box-shadow: none;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 8px;\n  padding: 0px 8px;\n  color: var(--color-foreground-2);\n  transition: background-color var(--anim-short);\n}\nbutton:hover, button:focus, button.selected {\n  background-color: var(--color-background-2);\n}\nbutton:active {\n  background-color: var(--color-background-1);\n}\nbutton.selected {\n  color: var(--color-accent);\n}</style>\n",
    "<script lang=\"ts\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { tick } from \"svelte\";\nimport { ui } from \"@app/stores/settings\";\nimport Icon from \"@components/Icon.svelte\";\nexport let value;\nexport let min = 0.01;\nexport let max = 999.99;\nlet readonly = true;\n$: fieldValue = value.toFixed(2);\n$: value = Math.min(max, Math.max(min, value));\nfunction handleKeyDown(e) {\n    if (e.key === \"Enter\") {\n        this.blur();\n    }\n}\nfunction handleDblClick() {\n    return __awaiter(this, void 0, void 0, function* () {\n        readonly = false;\n        yield tick();\n        this.focus();\n        this.select();\n    });\n}\nfunction handleBlur() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ([\"number\", \"string\"].includes(typeof fieldValue)) {\n            const num = Number(fieldValue);\n            // only update the value if it's valid\n            if (Number.isFinite(num)) {\n                value = num;\n            }\n        }\n        else {\n            // TODO: find a better way to update fieldValue ??\n            value = value + 1;\n            value = value - 1;\n        }\n        readonly = true;\n    });\n}\nfunction handleWheel(e) {\n    const side = Math.sign(e.deltaY);\n    const factor = e.shiftKey ? 2 : 1;\n    value -= side * factor;\n}\nfunction handlePointerDown(e) {\n    if (e.button !== 0) {\n        return;\n    }\n    const usedPointerLock = $ui.usePointerLock;\n    const startValue = value;\n    let deltaY = 0;\n    this.onpointermove = (e) => {\n        deltaY += e.movementY;\n        value = startValue - Math.round(deltaY / 4);\n    };\n    this.onpointerup = (e) => {\n        this.onpointermove = null;\n        this.onpointerup = null;\n        if (usedPointerLock) {\n            document.exitPointerLock();\n        }\n        else {\n            this.releasePointerCapture(e.pointerId);\n        }\n    };\n    if (usedPointerLock) {\n        this.requestPointerLock();\n    }\n    else {\n        this.setPointerCapture(e.pointerId);\n    }\n}\n</script>\n\n<div\n  class=\"tempo-root\"\n  on:wheel={handleWheel}\n  on:pointerdown={handlePointerDown}\n>\n  <input\n    {min}\n    {max}\n    type=\"number\"\n    bind:value={fieldValue}\n    {readonly}\n    on:blur={handleBlur}\n    on:dblclick={handleDblClick}\n    on:keydown={handleKeyDown}\n  />\n  <Icon name=\"arrow/unfold_more\" />\n</div>\n\n<style lang=\"scss\">.tempo-root {\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 2px 2px;\n  border-radius: 8px;\n  background: var(--color-background-1);\n  cursor: ns-resize;\n  color: var(--color-foreground-2);\n}\n.tempo-root input {\n  background: none;\n  color: inherit;\n  border: none;\n  padding: 0;\n  font: inherit;\n  cursor: pointer;\n  outline: inherit;\n  box-shadow: none;\n  width: 43px;\n  cursor: inherit;\n  text-align: center;\n  user-select: none;\n  border-radius: 6px;\n  font-size: 12px;\n  color: var(--color-foreground-0);\n}\n.tempo-root input[type=number] {\n  appearance: textfield;\n}\n.tempo-root input::-webkit-outer-spin-button, .tempo-root input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.tempo-root input:not([readonly]) {\n  background: var(--color-background-2);\n  cursor: text;\n}</style>\n",
    "<script lang=\"ts\">import { TracklistMode, ui } from \"@app/stores/settings\";\nimport Icon from \"@components/Icon.svelte\";\nimport Button from \"@components/control/Button.svelte\";\nimport TabbedControl from \"@components/control/TabbedControl.svelte\";\nimport ToggleButton from \"@components/control/ToggleButton.svelte\";\nimport TempoInput from \"./TempoInput.svelte\";\nimport PlayButton from \"./PlayButton.svelte\";\nimport project from \"@app/stores/project\";\nimport player from \"@app/stores/player\";\n</script>\n\n<nav>\n  <div class=\"group left\">\n    <div class=\"subgroup\">\n      <Button>\n        <Icon name=\"basic/stopwatch\" />\n      </Button>\n      <TempoInput bind:value={$project.tempo} />\n    </div>\n\n    <Button>\n      <Icon name=\"misc/dot_05_xl\" />\n    </Button>\n  </div>\n\n  <div class=\"group center\">\n    <div class=\"subgroup\">\n      <Button>\n        <Icon name=\"media/skip_previous\" />\n      </Button>\n      <PlayButton />\n      <ToggleButton icon=\"media/repeat\" selected />\n    </div>\n\n    <TabbedControl\n      bind:selected={$ui.tracklistMode}\n      tabs={[\n        { icon: \"edit/list_ul\", name: TracklistMode.Timeline },\n        { icon: \"basic/path\", name: TracklistMode.Graph },\n      ]}\n    />\n  </div>\n\n  <div class=\"group right\">\n    <Button>\n      <Icon name=\"basic/share\" />\n    </Button>\n  </div>\n</nav>\n\n<style lang=\"scss\">nav {\n  flex-shrink: 0;\n  flex-grow: 0;\n  height: 28px;\n  display: flex;\n  justify-content: space-between;\n  font-size: 16px;\n}\nnav .left,\nnav .right {\n  flex: 2;\n}\nnav .left {\n  justify-content: flex-start;\n}\nnav .right {\n  justify-content: flex-end;\n}\nnav .group,\nnav .subgroup {\n  display: inline-flex;\n  flex-direction: row;\n}\nnav .group {\n  gap: 32px;\n}\nnav .subgroup {\n  gap: 4px;\n}</style>\n",
    "<script lang=\"ts\">import { AudioTrack } from \"@api/audio\";\nimport project from \"@app/stores/project\";\nimport Icon from \"@components/Icon.svelte\";\nimport { createEventDispatcher } from \"svelte\";\nconst dispatch = createEventDispatcher();\nfunction handleClick() {\n    const track = new AudioTrack();\n    $project.tracks = [...$project.tracks, track];\n    dispatch(\"newtrack\", track);\n}\n</script>\n\n<button class=\"new-track-head\" on:click={handleClick}>\n  <Icon name=\"edit/plus\" />\n</button>\n\n<style lang=\"scss\">.new-track-head {\n  background: none;\n  color: inherit;\n  border: none;\n  padding: 0;\n  font: inherit;\n  cursor: pointer;\n  outline: inherit;\n  box-shadow: none;\n  flex-shrink: 0;\n  display: flex;\n  height: 64px;\n  align-items: center;\n  justify-content: center;\n  font-size: 24px;\n  color: var(--color-foreground-2);\n  background-color: var(--color-background-0);\n  border-radius: var(--corner-radius);\n  transition: background-color var(--anim-short), color var(--anim-short);\n}\n.new-track-head:hover, .new-track-head:focus {\n  background-color: var(--color-background-2);\n  color: var(--color-foreground-0);\n}\n.new-track-head:active {\n  background-color: var(--color-background-1);\n  color: var(--color-foreground-1);\n}</style>\n",
    "<script lang=\"ts\">import { createEventDispatcher } from \"svelte\";\n;\n;\nimport HStack from \"@components/layout/HStack.svelte\";\nimport VStack from \"@components/layout/VStack.svelte\";\nimport { grow } from \"@components/layout/Stack.svelte\";\nimport Checkbox from \"@components/control/Checkbox.svelte\";\nimport Knob from \"@components/control/Knob.svelte\";\nimport TextSpring from \"@components/TextSpring.svelte\";\nexport let selected = false;\nexport let track;\nconst dispatch = createEventDispatcher();\n// this is just the best way to handle right clicks on the web. boo!!\nfunction handleMuteContextMenu(e) {\n    // no we're not contextmenu-ing\n    e.preventDefault();\n    dispatch(\"solo\", track);\n}\n</script>\n\n<article\n  class=\"track-head\"\n  class:selected\n  class:disabled={!track.enabled}\n  on:pointerdown\n  style={`--track-height: ${track.height}px`}\n>\n  <HStack align=\"center\">\n    <div use:grow>\n      <HStack hpad={16} vpad={8} spacing={8} align=\"center\">\n        <Checkbox\n          size={10}\n          bind:checked={track.enabled}\n          on:contextmenu={handleMuteContextMenu}\n        />\n        <div use:grow>\n          <VStack>\n            <h2><TextSpring>{track.name}</TextSpring></h2>\n            {#if track.description}\n              <h3>{track.description}</h3>\n            {/if}\n          </VStack>\n        </div>\n      </HStack>\n    </div>\n    <div class=\"knobs\">\n      <VStack spacing={8} hpad={8}>\n        {#each track.mod.parameters as param}\n          <Knob\n            type={param.type}\n            min={param.min}\n            max={param.max}\n            bind:value={param.value}\n            disabled={!track.enabled}\n          />\n        {/each}\n      </VStack>\n    </div>\n  </HStack>\n</article>\n\n<style lang=\"scss\">.track-head {\n  display: grid;\n  background: var(--color-background-1);\n  height: var(--track-height);\n  border-radius: var(--corner-radius);\n  flex-shrink: 0;\n  overflow: hidden;\n  position: relative;\n}\n.track-head::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  width: calc(var(--corner-radius) / 2);\n  background: var(--color-accent);\n  opacity: 0.25;\n  transition: opacity var(--anim-short);\n}\n.track-head.selected {\n  background: var(--color-background-2);\n}\n.track-head.selected::before {\n  opacity: 1;\n}\n.track-head h2,\n.track-head h3 {\n  margin: 0;\n}\n.track-head h2 {\n  font-size: 12px;\n}\n.track-head h3 {\n  font-size: 10px;\n  color: var(--color-foreground-2);\n}\n.track-head h2,\n.track-head h3,\n.track-head .knobs {\n  transition: opacity var(--anim-short);\n}\n.track-head.disabled {\n  --color-accent: var(--color-foreground-1);\n}\n.track-head.disabled h2,\n.track-head.disabled h3,\n.track-head.disabled .knobs {\n  opacity: 0.5;\n}</style>\n",
    "<script lang=\"ts\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n;\nimport { writable } from \"svelte/store\";\nimport { tick, xlink_attr } from \"svelte/internal\";\nimport drag from \"@components/actions/drag\";\nimport project from \"@app/stores/project\";\nimport { ui, TracklistMode } from \"@app/stores/settings\";\nimport FlexSpace from \"@components/layout/FlexSpace.svelte\";\nimport SplitBar from \"@components/layout/SplitBar.svelte\";\nimport SplitPane from \"@components/layout/SplitPane.svelte\";\nimport VStack from \"@components/layout/VStack.svelte\";\nimport NewTrackHead from \"./NewTrackHead.svelte\";\nimport TrackHead from \"./TrackHead.svelte\";\nimport Timeline from \"./timeline/Timeline.svelte\";\nimport Graph from \"./graph/Graph.svelte\";\nimport commands from \"@components/actions/commands\";\nlet selectedTracks = new Set();\nlet tracklist = null;\nlet timeline = null;\nlet graph = null;\nlet scrollDelta = writable({ x: 0, y: 0 });\n$: if (tracklist) {\n    tracklist.scrollTop += $scrollDelta.y;\n}\n$: switch ($ui.tracklistMode) {\n    case TracklistMode.Timeline:\n        timeline === null || timeline === void 0 ? void 0 : timeline.scrollBy($scrollDelta.x);\n        break;\n    case TracklistMode.Graph:\n        graph === null || graph === void 0 ? void 0 : graph.scrollBy($scrollDelta.x);\n        break;\n}\nfunction deleteSelectedTracks() {\n    $project.tracks = $project.tracks.filter((track) => !selectedTracks.delete(track));\n}\nfunction selectTrack(track) {\n    selectedTracks = selectedTracks.add(track);\n    timeline === null || timeline === void 0 ? void 0 : timeline.selectAllClips(track);\n}\nfunction deselectAllTracks() {\n    selectedTracks.clear();\n    timeline === null || timeline === void 0 ? void 0 : timeline.deselectAllClips();\n    selectedTracks = selectedTracks;\n}\nfunction handleSolo(e) {\n    const track = e.detail;\n    const isSolo = $project.tracks.every((t) => t.enabled === (t === track));\n    // enable all the tracks if this track was the only one enabled\n    for (let i = 0; i < $project.tracks.length; i++) {\n        $project.tracks[i].enabled = isSolo || $project.tracks[i] === track;\n    }\n}\nfunction handleNewTrack() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield tick();\n        tracklist.scrollTop = tracklist.scrollHeight - tracklist.clientHeight;\n    });\n}\nfunction handleTrackClick(e, track, i) {\n    if (e.button === 0) {\n        selectTrack(track);\n        if (e.shiftKey && selectedTracks.size > 0) {\n            let range = null;\n            for (let j = 1; i + j < $project.tracks.length || i - j >= 0; j++) {\n                if (i + j < $project.tracks.length &&\n                    selectedTracks.has($project.tracks[i + j])) {\n                    range = [i, i + j];\n                    break;\n                }\n                if (i - j >= 0 && selectedTracks.has($project.tracks[i - j])) {\n                    range = [i - j, i];\n                    break;\n                }\n            }\n            if (range) {\n                for (let i = range[0]; i < range[1]; i++) {\n                    selectTrack($project.tracks[i]);\n                }\n            }\n        }\n    }\n}\n</script>\n\n<svelte:window\n  on:pointerdown|capture={(e) => {\n    if (e.button === 0 && !e.shiftKey && !e.ctrlKey) {\n      deselectAllTracks();\n    }\n  }}\n/>\n\n<div\n  bind:this={tracklist}\n  class=\"tracklist\"\n  use:commands={(e) => {\n    switch (e.detail) {\n      case \"timeline.track.delete\":\n        deleteSelectedTracks();\n        break;\n    }\n  }}\n  use:drag={{ button: 1, offset: scrollDelta, invert: true, relative: true }}\n  on:wheel={async (e) => {\n    e.preventDefault();\n\n    scrollDelta.set({\n      x: e.deltaX,\n      y: e.deltaY,\n    });\n\n    await tick();\n\n    scrollDelta.set({ x: 0, y: 0 });\n  }}\n>\n  <SplitPane\n    direction=\"row\"\n    min={150}\n    snaps={[150, 200, 250]}\n    bind:splitpos={$ui.trackHeadsWidth}\n  >\n    <VStack spacing={1}>\n      <VStack spacing={2}>\n        {#each $project.tracks as track, i (track)}\n          <TrackHead\n            bind:track\n            on:solo={handleSolo}\n            on:pointerdown={(e) => handleTrackClick(e, track, i)}\n            selected={selectedTracks.has(track)}\n          />\n          <SplitBar\n            bind:position={track.height}\n            snaps={[1, 2, 3, 4].map((x) => 64 * x)}\n            min={64}\n          />\n        {/each}\n      </VStack>\n      <FlexSpace />\n      <NewTrackHead on:newtrack={handleNewTrack} />\n    </VStack>\n    <div class=\"content\">\n      {#if $ui.tracklistMode === TracklistMode.Timeline}\n        <Timeline bind:this={timeline} />\n      {:else if $ui.tracklistMode === TracklistMode.Graph}\n        <Graph bind:this={graph} />\n      {/if}\n    </div>\n  </SplitPane>\n</div>\n\n<style lang=\"scss\">.tracklist {\n  display: grid;\n  overflow: hidden;\n  overflow-y: scroll;\n}\n.tracklist .content {\n  flex-grow: 1;\n  display: grid;\n}</style>\n",
    "<script lang=\"ts\" context=\"module\">;\n;\nexport {};\n</script>\n\n<script lang=\"ts\">;\nimport { get } from \"svelte/store\";\nimport { spring } from \"svelte/motion\";\nimport project from \"@app/stores/project\";\nimport VStack from \"@components/layout/VStack.svelte\";\nimport Link from \"./Link.svelte\";\nimport Node from \"./Node.svelte\";\nimport OutputPort from \"./OutputPort.svelte\";\nimport { rectCenter } from \"@app/utils/geom\";\nexport function scrollBy(xdelta) {\n    xscroll = Math.max(0, xscroll + xdelta);\n}\nlet xscroll = 0;\nlet context = {\n    xscroll,\n    nodeMap: new WeakMap(),\n    viewportElem: null,\n};\nlet pointerPos;\nlet viewportRect;\nlet wireVisible = false;\nlet wireSource;\nlet wireStartPos = { x: 0, y: 0 };\nlet wireEndPos = spring({ x: 0, y: 0 }, {\n    stiffness: 0.25,\n    damping: 1,\n});\n$: context.xscroll = xscroll;\n// reactive block executes when a new wire is being dragged out\n$: if (wireSource) {\n    // recompute the viewportRect\n    viewportRect = context.viewportElem.getBoundingClientRect();\n    // keep the source pos\n    wireStartPos = wireSource.pos;\n}\n// make the wire go back to its source pos when cancelled (cool animation)\n// then hide it\n$: if (wireSource === null) {\n    wireEndPos.set(wireStartPos).then(() => {\n        wireVisible = false;\n    });\n}\n$: if (wireSource) {\n    $wireEndPos = toViewportSpace(pointerPos);\n}\nfunction toViewportSpace(p) {\n    viewportRect = context.viewportElem.getBoundingClientRect();\n    return {\n        x: p.x - viewportRect.left,\n        y: p.y - viewportRect.top,\n    };\n}\nfunction portCenter(elem) {\n    return toViewportSpace(rectCenter(elem.getBoundingClientRect()));\n}\nfunction handleWireOut(pos, node, output) {\n    wireSource = { node, output, pos };\n    wireVisible = true;\n    // forcefully set the end position to the source pos\n    wireEndPos.set(wireSource.pos, { hard: true });\n}\n</script>\n\n<div\n  class=\"graph-viewport\"\n  bind:this={context.viewportElem}\n  on:pointermove={(e) => (pointerPos = { x: e.clientX, y: e.clientY })}\n  on:pointerup={() => (wireSource = null)}\n>\n  <div class=\"graph-content\" style={`transform: translateX(${-xscroll}px);`}>\n    <div class=\"track-outputs\">\n      <VStack spacing={4}>\n        {#each $project.tracks as track}\n          <div class=\"track\" style={`--track-height: ${track.height}px`}>\n            <OutputPort\n              bind:context\n              output={{ node: track, output: 0 }}\n              on:wireout={(e) =>\n                handleWireOut(portCenter(e.detail.portElem), track, 0)}\n            />\n          </div>\n        {/each}\n      </VStack>\n    </div>\n    {#each [...$project.graph.nodes] as node}\n      <Node\n        bind:context\n        bind:node\n        on:wiretake={(e) => {\n          const input = e.detail;\n          const output = node.inputs.get(input);\n          const outputPos = context.nodeMap\n            .get(output.node)\n            ?.get(output.output);\n\n          node = node.disconnectInput(input);\n\n          if (output) {\n            handleWireOut(\n              toViewportSpace(get(outputPos)),\n              output.node,\n              output.output\n            );\n            wireEndPos.set(toViewportSpace(pointerPos), { hard: true });\n          }\n        }}\n        on:wireout={(e) =>\n          handleWireOut(portCenter(e.detail.portElem), node, e.detail.output)}\n        on:connect={(e) => {\n          if (wireSource) {\n            const input = e.detail;\n\n            wireSource.node.connect(node, input, wireSource.output);\n            wireSource = null;\n            wireVisible = false;\n\n            // refresh the node\n            node = node;\n          }\n        }}\n      />\n    {/each}\n  </div>\n\n  {#if wireVisible}\n    <svg class=\"dragged-wire\" class:visible={!!wireSource}>\n      <Link source={wireStartPos} target={$wireEndPos} />\n    </svg>\n  {/if}\n</div>\n\n<style lang=\"scss\">.graph-viewport {\n  position: relative;\n  overflow: hidden;\n}\n.graph-viewport .track-outputs {\n  position: absolute;\n}\n.graph-viewport .track-outputs .track {\n  display: inline-flex;\n  height: var(--track-height);\n  flex-direction: column;\n  justify-content: space-evenly;\n}\n.graph-viewport .dragged-wire {\n  position: absolute;\n  color: var(--color-foreground-2);\n  overflow: visible;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity var(--anim-short);\n}\n.graph-viewport .dragged-wire.visible {\n  opacity: 1;\n}</style>\n",
    "<script lang=\"ts\">var _a, _b;\n;\n;\n;\nimport { createEventDispatcher, onDestroy } from \"svelte\";\nimport { rectCenter } from \"@app/utils/geom\";\nimport Link from \"./Link.svelte\";\nexport let context;\nexport let link;\nexport let size = 8;\nexport let color = \"var(--color-foreground-2)\";\nconst dispatch = createEventDispatcher();\nlet elem = null;\nlet linkTarget = null;\nlet linkTargetUnsub = null;\n// unlink!\n$: if (!link) {\n    linkTarget = null;\n    if (linkTargetUnsub) {\n        linkTargetUnsub();\n        linkTargetUnsub = null;\n    }\n}\n// link!\n$: if (link && elem) {\n    if (linkTargetUnsub) {\n        linkTargetUnsub();\n        linkTargetUnsub = null;\n    }\n    linkTargetUnsub = (_b = (_a = context.nodeMap\n        .get(link.node)) === null || _a === void 0 ? void 0 : _a.get(link.output)) === null || _b === void 0 ? void 0 : _b.subscribe((val) => {\n        if (val) {\n            const rect = elem.getBoundingClientRect();\n            const center = rectCenter(rect, true);\n            linkTarget = {\n                x: val.x - rect.left - center.x,\n                y: val.y - rect.top - center.y,\n            };\n        }\n    });\n}\nonDestroy(() => {\n    if (linkTargetUnsub) {\n        linkTargetUnsub();\n    }\n});\n</script>\n\n<div\n  on:pointerup={(e) => e.button === 0 && dispatch(\"connect\")}\n  on:pointerdown={(e) => e.button === 0 && dispatch(\"wiretake\")}\n  bind:this={elem}\n  class=\"graph-port\"\n  style={`\n    color: ${color};\n  `}\n>\n  <svg width={size} height={size}>\n    <circle\n      class=\"port-dot\"\n      style=\"r: var(--dot-size)\"\n      cx={size / 2}\n      cy={size / 2}\n      fill=\"currentColor\"\n    />\n  </svg>\n\n  {#if linkTarget}\n    <svg class=\"link\">\n      <Link source={{ x: 0, y: 0 }} target={linkTarget} />\n    </svg>\n  {/if}\n</div>\n\n<style lang=\"scss\">.graph-port {\n  padding: 4px;\n  position: relative;\n  line-height: 0;\n  --dot-size: 25%;\n}\n.graph-port:hover {\n  --dot-size: 40%;\n}\n.graph-port .port-dot {\n  transition: r var(--anim-short);\n}\n.graph-port .link {\n  color: var(--color-foreground-2);\n  overflow: visible;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  pointer-events: none;\n}</style>\n",
    "<script lang=\"ts\">export let source;\nexport let target;\nexport let linkWidth = \"2\";\nexport let stiffness = ({ x }) => 1 + 1 / (-1 - Math.abs(x) / 300);\n$: delta = {\n    x: target.x - source.x,\n    y: target.y - source.y,\n};\n$: stiffnessValue = Math.max(0, Math.min(1, typeof stiffness === \"number\" ? stiffness : stiffness(Object.assign({}, delta))));\n$: invStiffness = 1.0 - stiffnessValue;\n</script>\n\n<path\n  class=\"link\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width={linkWidth}\n  d={`\n    M ${source.x},${source.y}\n    c ${delta.x * invStiffness},${0}\n      ${delta.x * stiffnessValue},${delta.y}\n      ${delta.x},${delta.y}\n  `}\n/>\n<circle cx={source.x} cy={source.y} r=\"4\" fill=\"currentColor\" />\n<circle\n  cx={source.x + delta.x}\n  cy={source.y + delta.y}\n  r=\"4\"\n  fill=\"currentColor\"\n/>\n\n<style lang=\"scss\">.link {\n  transition: opacity var(--anim-short);\n  transition: stroke-width var(--anim-short);\n}</style>\n",
    "<script lang=\"ts\">;\n;\n;\nimport { createEventDispatcher } from \"svelte\";\nimport drag from \"@components/actions/drag\";\nimport Checkbox from \"@components/control/Checkbox.svelte\";\nimport Knob from \"@components/control/Knob.svelte\";\nimport Icon from \"@components/Icon.svelte\";\nimport FlexSpace from \"@components/layout/FlexSpace.svelte\";\nimport HStack from \"@components/layout/HStack.svelte\";\nimport VStack from \"@components/layout/VStack.svelte\";\nimport { writable } from \"svelte/store\";\nimport InputPort from \"./InputPort.svelte\";\nimport OutputPort from \"./OutputPort.svelte\";\nexport let context;\nexport let node;\nconst dispatch = createEventDispatcher();\nlet dragOffset = writable({ x: node.x, y: node.y });\n// no circular dependency here because `writable` is lazy\nfunction updateDragOffset(pos) {\n    $dragOffset.x = pos.x;\n    $dragOffset.y = pos.y;\n}\nfunction updateNodePos(pos) {\n    node.x = pos.x;\n    node.y = pos.y;\n}\n$: updateDragOffset(node);\n$: updateNodePos($dragOffset);\n</script>\n\n<section\n  class=\"module\"\n  class:disabled={!node.enabled}\n  style={`\n    transform: translate(${node.x}px, ${node.y}px);\n  `}\n>\n  <div class=\"inputs\">\n    <VStack spacing={8}>\n      {#each { length: node.mod.inputs } as _, input}\n        <InputPort\n          bind:context\n          link={node.inputs.get(input)}\n          on:wiretake={() => dispatch(\"wiretake\", input)}\n          on:connect={() => dispatch(\"connect\", input)}\n        />\n      {/each}\n    </VStack>\n  </div>\n\n  <div class=\"outputs\">\n    <VStack spacing={8}>\n      {#each { length: node.mod.outputs } as _, output}\n        <OutputPort\n          bind:context\n          output={{ node, output }}\n          on:wireout={(e) =>\n            dispatch(\"wireout\", {\n              output,\n              portElem: e.detail.portElem,\n            })}\n        />\n      {/each}\n    </VStack>\n  </div>\n\n  <VStack>\n    <header use:drag={{ button: 0, offset: dragOffset }}>\n      <HStack hpad={4} vpad={2} spacing={8} align=\"center\">\n        <HStack hpad={4} vpad={2} spacing={8} align=\"center\">\n          <Checkbox bind:checked={node.enabled} size={8} />\n          <h2>{node.mod.name}</h2>\n        </HStack>\n        <FlexSpace />\n        <Icon name=\"arrow/chevron_down\" color=\"var(--color-foreground-2)\" />\n      </HStack>\n    </header>\n    <div class=\"parameters\">\n      <HStack hpad={8} spacing={16} align=\"end\">\n        {#each node.mod.parameters as param}\n          <div class=\"parameter\">\n            <VStack align=\"center\" spacing={2} vpad={4}>\n              <Knob\n                id={`${node.id}-${param.name}`}\n                bind:value={param.value}\n                type={param.type}\n                min={param.min}\n                max={param.max}\n                disabled={!node.enabled}\n              />\n              <label for={`${node.id}-${param.name}`}>{param.name}</label>\n            </VStack>\n          </div>\n        {/each}\n      </HStack>\n    </div>\n  </VStack>\n</section>\n\n<style lang=\"scss\">.module {\n  display: grid;\n  position: absolute;\n  height: 64px;\n  background: var(--color-background-1);\n  border-radius: var(--corner-radius);\n}\n.module h2 {\n  font-size: 12px;\n  transition: opacity var(--anim-short);\n}\n.module .inputs,\n.module .outputs {\n  display: flex;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n}\n.module .inputs {\n  right: 100%;\n}\n.module .outputs {\n  left: 100%;\n}\n.module .parameters {\n  display: grid;\n  justify-items: center;\n}\n.module .parameters .parameter label {\n  font-size: 10px;\n  color: var(--color-foreground-1);\n}\n.module.disabled h2 {\n  opacity: 0.5;\n}</style>\n",
    "<script lang=\"ts\">;\n;\n;\nimport { createEventDispatcher } from \"svelte\";\nimport { writable } from \"svelte/store\";\nimport { rectCenter } from \"@app/utils/geom\";\nexport let context;\nexport let output;\nexport let size = 16;\nexport let color = \"var(--color-foreground-2)\";\nconst dispatch = createEventDispatcher();\nlet elem = undefined;\nlet elemCenter;\n$: if (elem) {\n    // be reactive to output.node and output.output\n    // when the node moves, output.node is changed because it contains the\n    // position\n    output;\n    context.xscroll;\n    // update the center of this port\n    elemCenter = rectCenter(elem.getBoundingClientRect());\n}\n// maintain ourselves in the outputMap\n$: if (output) {\n    // get the (number => point) map for this node\n    let outputMap = context.nodeMap.get(output.node);\n    // it can be undefined if this is the first output (id=0)\n    if (!outputMap) {\n        // create it empty\n        outputMap = new Map();\n        // assign it to the nodeMap\n        context.nodeMap.set(output.node, outputMap);\n    }\n    // get the store storing the point\n    let point = outputMap.get(output.output);\n    // it can be undefined if this is the first time we set it\n    if (!point) {\n        // create an empty store for it\n        point = writable(null);\n        // assign it to this node's outputMap\n        outputMap.set(output.output, point);\n    }\n    // update it\n    point.set(elemCenter);\n}\n</script>\n\n<div\n  on:pointerdown={(e) => {\n    if (e.button !== 0) {\n      return;\n    }\n\n    dispatch(\"wireout\", { portElem: e.currentTarget });\n  }}\n  bind:this={elem}\n  class=\"output-port\"\n  style={`\n    color: ${color};\n  `}\n>\n  <svg width={size} height={size}>\n    <clipPath id=\"hole-clip\">\n      <circle cx=\"0%\" cy=\"0%\" r=\"50%\" />\n    </clipPath>\n\n    <g class=\"port-group\">\n      <circle\n        clip-path=\"url('#hole-clip')\"\n        cx=\"0%\"\n        cy=\"0%\"\n        r=\"50%\"\n        stroke=\"currentColor\"\n        stroke-width=\"50%\"\n        fill=\"none\"\n        class=\"circle\"\n      />\n    </g>\n  </svg>\n</div>\n\n<style lang=\"scss\">.output-port {\n  line-height: 0;\n  --scale: 0.5;\n  --link-width: 2px;\n}\n.output-port svg {\n  overflow: visible;\n}\n.output-port .port-group {\n  transition: transform var(--anim-short);\n  transform: translate(50%, 50%) scale(var(--scale));\n}\n.output-port .circle {\n  transition: stroke-width var(--anim-short);\n}\n.output-port:hover {\n  --scale: 0.75;\n  --link-width: 4px;\n}</style>\n",
    "<script lang=\"ts\">import player from \"@app/stores/player\";\nexport let blob;\nexport let visibleRange;\nexport let detail = 1;\nexport let lineWidth = 1;\nexport let debugRange = false;\nlet decodedBuffer;\nlet width;\nlet renderWidth = 0;\nlet renderRange = [0, 0];\nlet redrawTimeout;\nlet path = \"\";\n$: $player.decodeBlob(blob).then((buffer) => {\n    if (decodedBuffer !== buffer) {\n        decodedBuffer = buffer;\n    }\n});\n$: if (visibleRange[0] !== renderRange[0] ||\n    visibleRange[1] !== renderRange[1] ||\n    width !== renderWidth) {\n    scheduleRender(decodedBuffer, visibleRange);\n}\nfunction scheduleRender(buffer, range) {\n    if (redrawTimeout) {\n        clearTimeout(redrawTimeout);\n    }\n    redrawTimeout = setTimeout(() => {\n        redrawTimeout = null;\n        requestAnimationFrame(() => {\n            renderWaveform(buffer, range);\n        });\n    }, 100);\n}\nfunction renderWaveform(buffer, range) {\n    const rangeDuration = range[1] - range[0];\n    if (rangeDuration <= 0) {\n        return \"\";\n    }\n    const rangeWidth = width * (rangeDuration / buffer.duration);\n    const rangeSamples = rangeDuration * buffer.sampleRate;\n    const detailSamples = rangeSamples * (detail / rangeWidth);\n    const sampleRange = range.map((t) => Math.round(t * buffer.sampleRate));\n    const xoffset = (width * range[0]) / buffer.duration;\n    let pathBuilder = \"\";\n    const channels = new Array(buffer.numberOfChannels);\n    for (let i = 0; i < buffer.numberOfChannels; i++) {\n        channels[i] = buffer.getChannelData(i);\n    }\n    if (detailSamples > 1) {\n        let lastMin = -1;\n        let lastMax = 1;\n        for (let bar = 0; bar * detail < rangeWidth; bar++) {\n            const sample = sampleRange[0] + bar * detailSamples;\n            let min = 1;\n            let max = -1;\n            for (const channel of channels) {\n                for (let s = sample | 0; s < sample + detailSamples; s++) {\n                    const i = ((s % channel.length) + channel.length) % channel.length;\n                    min = Math.min(min, channel[i]);\n                    max = Math.max(max, channel[i]);\n                }\n            }\n            min = Math.min(min, lastMax);\n            max = Math.max(max, lastMin);\n            lastMin = min;\n            lastMax = max;\n            pathBuilder += `M${xoffset + detail * bar},${min}V${max}`;\n        }\n    }\n    else {\n        const sampleWidth = rangeWidth / (sampleRange[1] - sampleRange[0]);\n        for (const channel of channels) {\n            for (let s = sampleRange[0]; s < sampleRange[1]; s++) {\n                const i = ((s % channel.length) + channel.length) % channel.length;\n                if (s === sampleRange[0]) {\n                    pathBuilder += `M${xoffset},${channel[i]}`;\n                }\n                else {\n                    pathBuilder += `V${channel[i]}`;\n                }\n                pathBuilder += `h${sampleWidth}`;\n            }\n        }\n    }\n    path = pathBuilder;\n    renderRange[0] = range[0];\n    renderRange[1] = range[1];\n    renderWidth = width;\n}\n</script>\n\n<div class=\"audio-waveform\" bind:clientWidth={width}>\n  <svg preserveAspectRatio=\"none\" viewBox={`0 0 ${renderWidth} 2`}>\n    <path\n      transform=\"translate(0 1) scale(1 0.9)\"\n      fill=\"none\"\n      vector-effect=\"non-scaling-stroke\"\n      stroke=\"currentColor\"\n      stroke-width={lineWidth}\n      d={path}\n    />\n\n    {#if decodedBuffer && debugRange}\n      <path\n        d={`\n            M ${width * (visibleRange[0] / decodedBuffer.duration)},0\n            h 30\n            m -30,0\n            l 10,10\n            m -10,-10\n            l 10,-10\n\n            M ${width * (visibleRange[1] / decodedBuffer.duration)},0\n            h -30\n            m 30,0\n            l -10,10\n            m 10,-10\n            l -10,-10\n          `}\n        fill=\"none\"\n        stroke=\"var(--color-background-0)\"\n        stroke-width=\"2\"\n      />\n    {/if}\n  </svg>\n</div>\n\n<style lang=\"scss\">.audio-waveform {\n  width: 100%;\n  height: 100%;\n}\n.audio-waveform svg {\n  overflow: visible;\n  width: 100%;\n  height: 100%;\n}</style>\n",
    "<script lang=\"ts\">;\nimport { AudioClip } from \"@api/audio\";\nimport AudioWaveform from \"./AudioWaveform.svelte\";\nimport project from \"@app/stores/project\";\nexport let clip;\nexport let selected = false;\nexport let viewRegion;\nexport let snap;\nexport let secWidth;\nexport let color = \"var(--color-red)\";\nvar ResizeSide;\n(function (ResizeSide) {\n    ResizeSide[\"Start\"] = \"start\";\n    ResizeSide[\"End\"] = \"end\";\n})(ResizeSide || (ResizeSide = {}));\nlet visibleRange;\n$: visibleRange = [\n    Math.max(viewRegion[0] - clip.start - clip.extentPast, 0) + clip.extentPast,\n    clip.extent + Math.min(viewRegion[1] - clip.start - clip.extent, 0),\n];\nfunction resizer(node, side) {\n    function handlePointerDown(e) {\n        if (e.button !== 0) {\n            return;\n        }\n        e.stopPropagation();\n        e.preventDefault();\n        const start = {\n            x: e.clientX,\n            timePoint: side === ResizeSide.Start ? clip.extentPast : clip.extent,\n            extent: clip.extent,\n        };\n        const pointermove = (e) => {\n            const dt = (e.clientX - start.x) / secWidth;\n            let t = start.timePoint + dt;\n            if (!e.altKey) {\n                t = Math.round(t / snap) * snap;\n            }\n            if (side === ResizeSide.Start) {\n                clip.extentPast = Math.max(Math.min(t, clip.extent - $project.quantum), -clip.start);\n            }\n            else {\n                clip.extent = Math.max(t, clip.extentPast + $project.quantum);\n            }\n        };\n        const pointerup = (e) => {\n            this.removeEventListener(\"pointermove\", pointermove);\n            this.removeEventListener(\"pointerup\", pointerup);\n            this.releasePointerCapture(e.pointerId);\n        };\n        this.addEventListener(\"pointermove\", pointermove);\n        this.addEventListener(\"pointerup\", pointerup);\n        this.setPointerCapture(e.pointerId);\n    }\n    node.addEventListener(\"pointerdown\", handlePointerDown);\n    return {\n        update(newSide) {\n            side = newSide;\n        },\n        destroy() {\n            node.removeEventListener(\"pointerdown\", handlePointerDown);\n        },\n    };\n}\n</script>\n\n<div\n  on:pointerdown\n  class=\"clip\"\n  class:selected\n  style={`\n    --clip-color: ${color};\n    transform: translateX(${Math.round(\n      (clip.start + clip.extentPast) * secWidth\n    )}px);\n  `}\n>\n  <div class=\"resize-handle\" use:resizer={ResizeSide.Start} />\n  <div\n    class=\"content\"\n    style={`width: ${Math.round(Math.max(clip.totalExtent * secWidth, 1))}px`}\n  >\n    <header>\n      <h3>{clip.name}</h3>\n    </header>\n    <div\n      class=\"data\"\n      style={`\n        transform: translateX(${-clip.extentPast * secWidth}px);\n        width: ${clip.length * secWidth}px;\n      `}\n    >\n      {#if clip instanceof AudioClip}\n        <AudioWaveform blob={clip.blob} {visibleRange} />\n      {/if}\n    </div>\n  </div>\n  <div class=\"resize-handle\" use:resizer={ResizeSide.End} />\n</div>\n\n<style lang=\"scss\">.clip {\n  display: flex;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  color: var(--color-foreground-0);\n  --header-background-opacity: 0.6;\n  --header-background-color: var(--clip-color);\n  --header-foreground-color: var(--color-foreground-0);\n  --background-opacity: 0.05;\n  --background-tint: 0;\n}\n.clip.selected {\n  --background-tint: 0.15;\n  --header-background-opacity: 0.8;\n}\n.clip::before {\n  content: \"\";\n  display: inline-block;\n  border-radius: var(--corner-radius);\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: var(--color-accent);\n  opacity: var(--background-tint);\n  transition: opacity var(--anim-short);\n}\n.clip .content {\n  display: flex;\n  flex-direction: column;\n  border-radius: var(--corner-radius);\n  overflow: hidden;\n  position: relative;\n}\n.clip .content header {\n  flex-shrink: 0;\n  position: relative;\n  color: var(--header-foreground-color);\n}\n.clip .content header::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: var(--header-background-color);\n  opacity: var(--header-background-opacity);\n  transition: opacity var(--anim-short);\n}\n.clip .content header h3 {\n  position: sticky;\n  font-size: 11px;\n  padding: 2px 4px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.clip .content::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  border-radius: inherit;\n  background: var(--color-foreground-0);\n  opacity: var(--background-opacity);\n  transition: opacity var(--anim-short);\n}\n.clip .content .data {\n  flex-shrink: 0;\n  flex-grow: 1;\n}\n.clip .resize-handle {\n  flex-basis: 0;\n  position: relative;\n  width: 0px;\n  cursor: ew-resize;\n}\n.clip .resize-handle::after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: -4px;\n  bottom: 0;\n  width: 8px;\n  z-index: 1;\n}</style>\n",
    "<script lang=\"ts\">;\n;\n;\n;\nimport { tweened } from \"svelte/motion\";\nimport { cubicOut } from \"svelte/easing\";\nimport project from \"@app/stores/project\";\nimport player from \"@app/stores/player\";\nimport commands from \"@components/actions/commands\";\nimport VStack from \"@components/layout/VStack.svelte\";\nimport TimelineTrack from \"./Track.svelte\";\nlet selectedClips = new Set();\nlet cursorPos = 0;\nlet timelineWidth = 300;\nlet viewRegion = [0, 20];\nlet secWidth;\nlet snap;\nlet movedClip = null;\nlet pointerStart;\nlet animatedViewRegion = tweened(viewRegion, {\n    duration: 100,\n    easing: cubicOut,\n});\nexport function scrollBy(xdelta) {\n    const span = viewRegion[1] - viewRegion[0];\n    viewRegion[0] = Math.max(0, viewRegion[0] + xdelta / secWidth);\n    viewRegion[1] = viewRegion[0] + span;\n}\nexport function selectAllClips(track) {\n    for (const clip of track.clips) {\n        selectedClips.add(clip);\n    }\n    selectedClips = selectedClips;\n}\nexport function deselectAllClips(track) {\n    if (track) {\n        for (const clip of track.clips) {\n            selectedClips.delete(clip);\n        }\n    }\n    else {\n        selectedClips.clear();\n    }\n    selectedClips = selectedClips;\n}\n$: animatedViewRegion.set([viewRegion[0], viewRegion[1]]);\n$: secWidth =\n    timelineWidth / ($animatedViewRegion[1] - $animatedViewRegion[0]);\n$: {\n    // snap is 1 bar by default\n    snap = $project.barsToTime(1);\n    for (let i = 0; i < 8 && (snap / 2) * secWidth >= 15; i++) {\n        snap /= 2;\n    }\n    if ((snap / 2) * secWidth >= 20) {\n        snap = $project.quantum;\n    }\n}\n$: if ($player.playing) {\n    const update = () => {\n        if ($player.playing) {\n            cursorPos = ($player.currentTime - $animatedViewRegion[0]) * secWidth;\n            requestAnimationFrame(update);\n        }\n    };\n    update();\n}\nelse {\n    cursorPos = ($player.startCursor - $animatedViewRegion[0]) * secWidth;\n}\nfunction initTimelineWidth(node) {\n    timelineWidth = node.getBoundingClientRect().width;\n}\nfunction handleWheel(e) {\n    if (e.ctrlKey) {\n        e.preventDefault();\n        const rect = this.getBoundingClientRect();\n        const wheelDelta = Math.sign(e.deltaY);\n        const scaling = 1.0 + wheelDelta * 0.1;\n        const aimedTime = $animatedViewRegion[0] + (e.clientX - rect.left) / secWidth;\n        for (let i = 0; i < 2; i++) {\n            const t = viewRegion[i];\n            const d = t - aimedTime;\n            viewRegion[i] = Math.max(0, aimedTime + d * scaling);\n        }\n    }\n}\nfunction handleGlobalKeyDown(e) {\n    if (e.key === \"Alt\") {\n        e.preventDefault();\n    }\n}\nfunction handleGlobalKeyUp(e) {\n    if (e.key === \"Alt\") {\n        e.preventDefault();\n    }\n}\n</script>\n\n<svelte:window\n  on:keydown={handleGlobalKeyDown}\n  on:keyup={handleGlobalKeyUp}\n  on:pointerdown|capture={(e) => {\n    if (e.button === 0 && !e.shiftKey && !e.ctrlKey) {\n      selectedClips.clear();\n      selectedClips = selectedClips;\n    }\n  }}\n  on:pointerup={(e) => {\n    if (e.button !== 0) {\n      return;\n    }\n\n    movedClip = null;\n  }}\n/>\n\n<div\n  class=\"timeline\"\n  use:initTimelineWidth\n  bind:clientWidth={timelineWidth}\n  on:wheel={handleWheel}\n  use:commands={(e) => {\n    switch (e.detail) {\n      case \"timeline.clip.delete\":\n        for (const track of $project.tracks) {\n          track.clips = track.clips.filter((clip) => !selectedClips.has(clip));\n        }\n\n        selectedClips.clear();\n        selectedClips = selectedClips;\n        break;\n      case \"timeline.clip.duplicate\":\n        for (const track of $project.tracks) {\n          const duplicatedClips = track.clips.filter((clip) =>\n            selectedClips.has(clip)\n          );\n\n          for (const clip of duplicatedClips) {\n            // create a clone and leave it here\n            track.clips.push(clip.duplicate());\n\n            // move the selected clip forward\n            clip.start += clip.totalExtent;\n          }\n        }\n\n        selectedClips = selectedClips;\n        break;\n    }\n  }}\n  on:pointerdown|capture={(e) => {\n    if (e.button === 0) {\n      pointerStart = { x: e.clientX, y: e.clientY };\n    }\n  }}\n  on:pointermove={(e) => {\n    if (movedClip) {\n      const delta = e.clientX - pointerStart.x;\n      let start = movedClip.start + delta / secWidth;\n\n      if (!e.altKey) {\n        start = Math.round(start / snap) * snap;\n      }\n\n      start = Math.max(-movedClip.clip.extentPast, start);\n      movedClip.clip.start = start;\n\n      $project.tracks = $project.tracks;\n    }\n  }}\n>\n  <VStack spacing={4}>\n    {#each $project.tracks as track}\n      <TimelineTrack\n        bind:track\n        viewRegion={$animatedViewRegion}\n        {secWidth}\n        {snap}\n        {selectedClips}\n        on:pointerenter={() => {\n          if (movedClip && track.mod.canPlay(movedClip.clip)) {\n            movedClip.track.clips = movedClip.track.clips.filter(\n              (clip) => clip !== movedClip.clip\n            );\n            track.clips = [...track.clips, movedClip.clip];\n            movedClip.track = track;\n          }\n        }}\n        on:pointerdownclip={(e) => {\n          if (e.detail.e.button !== 0) {\n            return;\n          }\n\n          movedClip = {\n            clip: e.detail.clip,\n            start: e.detail.clip.start,\n            track,\n          };\n          selectedClips = selectedClips.add(e.detail.clip);\n        }}\n      />\n    {/each}\n  </VStack>\n  <div class=\"cursor\" style={`--x: ${cursorPos}px`} />\n</div>\n\n<style lang=\"scss\">.timeline {\n  position: relative;\n  overflow: hidden;\n}\n.timeline .cursor {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  width: 1px;\n  background: var(--color-accent);\n  opacity: 0.5;\n  transform: translateX(var(--x));\n}</style>\n",
    "<script lang=\"ts\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n;\nimport { createEventDispatcher, onMount } from \"svelte\";\nimport { AbstractClip, Track } from \"@api/timeline\";\nimport { AudioClip } from \"@api/audio\";\nimport project from \"@app/stores/project\";\nimport player from \"@app/stores/player\";\nimport ClipComponent from \"./Clip.svelte\";\nexport let track;\nexport let viewRegion;\nexport let snap;\nexport let secWidth;\nexport let selectedClips;\nconst dispatch = createEventDispatcher();\nlet backgroundCanvas;\nlet backgroundWidth;\nlet backgroundHeight;\nlet backgroundFrame;\nlet ctx;\nlet ghostClip = null;\nconst audioTypes = /^audio\\/.+/;\nfunction insertAudioClip(time, name, blob) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const buffer = yield $player.decodeBlob(blob);\n        const clip = new AudioClip(name, blob, 0, buffer.duration);\n        clip.start = time;\n        track.clips = [...track.clips, clip];\n    });\n}\nfunction computeDropTime(e) {\n    const target = e.currentTarget;\n    let time = viewRegion[0] + e.clientX / secWidth;\n    if (target instanceof HTMLElement) {\n        const rect = target.getBoundingClientRect();\n        time -= rect.x / secWidth;\n    }\n    if (!e.altKey) {\n        time = Math.round(time / snap) * snap;\n    }\n    return time;\n}\nfunction handleDragOver(e) {\n    if (e.dataTransfer.types.includes(\"Files\")) {\n        const time = computeDropTime(e);\n        if (!ghostClip) {\n            ghostClip = new AbstractClip(\"Audio clip\");\n            ghostClip.length = ghostClip.extent = $project.barsToTime(1);\n        }\n        ghostClip.start = time;\n        e.preventDefault();\n        e.dataTransfer.dropEffect = \"copy\";\n    }\n}\nfunction handleDragLeave(e) {\n    ghostClip = null;\n}\nfunction handleDrop(e) {\n    e.preventDefault();\n    ghostClip = null;\n    const files = e.dataTransfer.files;\n    const time = computeDropTime(e);\n    for (const file of files) {\n        if (file.type.match(audioTypes)) {\n            insertAudioClip(time, file.name, file);\n        }\n    }\n}\nfunction drawRegions(ctx, width, divwidth, scroll) {\n    const xoffset = scroll % (divwidth * 2);\n    ctx.beginPath();\n    for (let i = 1; i * divwidth - xoffset < width; i += 2) {\n        ctx.rect(i * divwidth - xoffset, 0, divwidth, 1);\n    }\n}\nfunction drawDivisions(ctx, width, divwidth, scroll) {\n    const xoffset = scroll % divwidth;\n    ctx.beginPath();\n    for (let i = 0; i * divwidth - xoffset < width; i++) {\n        ctx.moveTo(i * divwidth - xoffset, 0);\n        ctx.lineTo(i * divwidth - xoffset, 1);\n    }\n}\nfunction redrawBackground() {\n    backgroundFrame !== null && backgroundFrame !== void 0 ? backgroundFrame : cancelAnimationFrame(backgroundFrame);\n    backgroundFrame = requestAnimationFrame(() => {\n        if (!backgroundCanvas) {\n            return;\n        }\n        ctx = ctx !== null && ctx !== void 0 ? ctx : backgroundCanvas.getContext(\"2d\");\n        backgroundCanvas.width = backgroundWidth * window.devicePixelRatio;\n        backgroundCanvas.height = backgroundHeight * window.devicePixelRatio;\n        const height = backgroundCanvas.height;\n        const style = getComputedStyle(backgroundCanvas);\n        const color = style.getPropertyValue(\"--color-background-0\");\n        const bg = style.getPropertyValue(\"--color-background-1\");\n        backgroundFrame = null;\n        ctx.save();\n        {\n            ctx.scale(1, height);\n            ctx.strokeStyle = color;\n            ctx.fillStyle = bg;\n            drawRegions(ctx, backgroundWidth, $project.barsToTime(4) * secWidth, viewRegion[0] * secWidth);\n            ctx.fill();\n            drawDivisions(ctx, backgroundWidth, snap * secWidth, viewRegion[0] * secWidth);\n            ctx.globalAlpha = 0.5;\n            ctx.stroke();\n            drawDivisions(ctx, backgroundWidth, $project.barsToTime(1) * secWidth, viewRegion[0] * secWidth);\n            ctx.globalAlpha = 1;\n            ctx.stroke();\n        }\n        ctx.restore();\n    });\n}\n$: {\n    // redraw when any of these change\n    $project.tempo;\n    $project.signature;\n    backgroundWidth;\n    backgroundHeight;\n    viewRegion;\n    secWidth;\n    redrawBackground();\n}\n</script>\n\n<div\n  class=\"track\"\n  class:disabled={!track.enabled}\n  on:pointerenter\n  on:dragover={handleDragOver}\n  on:dragleave={handleDragLeave}\n  on:drop={handleDrop}\n  style={`\n    height: ${track.height}px;\n    --xscroll: ${viewRegion[0] * secWidth}px;\n    --snap-width: ${snap * secWidth}px;\n    --bar-width: ${$project.barsToTime(1) * secWidth}px;\n    --beat-width: ${$project.beatsToTime(1) * secWidth}px;\n  `}\n>\n  <canvas\n    class=\"grid\"\n    bind:this={backgroundCanvas}\n    bind:clientWidth={backgroundWidth}\n    bind:clientHeight={backgroundHeight}\n  />\n  <div class=\"clips\">\n    {#each track.clips as clip (clip)}\n      <ClipComponent\n        bind:clip\n        selected={selectedClips.has(clip)}\n        {secWidth}\n        {snap}\n        {viewRegion}\n        on:pointerdown={(e) => dispatch(\"pointerdownclip\", { clip, e })}\n      />\n    {/each}\n  </div>\n\n  <div class=\"ghost-clip\">\n    {#if ghostClip}\n      <ClipComponent\n        bind:clip={ghostClip}\n        {secWidth}\n        {snap}\n        {viewRegion}\n        on:cliptake\n      />\n    {/if}\n  </div>\n</div>\n\n<style lang=\"scss\">.track {\n  border-radius: var(--corner-radius);\n  background: var(--color-background-2);\n  transition: opacity var(--anim-short);\n  position: relative;\n  overflow: hidden;\n}\n.track.disabled {\n  opacity: 0.5;\n}\n.track .grid {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  color: var(--color-background-0);\n}\n.track .clips,\n.track .ghost-clip {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  transform: translateX(calc(var(--xscroll) * -1));\n}\n.track .ghost-clip {\n  opacity: 0.5;\n  pointer-events: none;\n}</style>\n"
  ],
  "names": [],
  "mappings": "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"
}